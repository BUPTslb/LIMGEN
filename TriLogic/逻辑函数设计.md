设计三种逻辑函数
0. testbench
有一种情况，需要对原始代码进行优化

A <= "10010111";

这其实是赋值操作，后续使用的A就是10010111，和前面的没关系了，正如同寄存器重命名，需要对变量进行重命名。

对于立即数，查dst_id的表会得出0，可以把这个特性当成立即数的标志。

0. 阵列参数
三个阵列的迭代参数：
    1. LUT：  读时间 写时间 读功耗 写功耗 （执行=读）
    2. SA：   读时间 写时间 执行时间 读功耗 写功耗 执行功耗 （执行 ～= 读）
    3. MAGIC：读时间 写时间 执行时间 读功耗 写功耗 执行功耗 （执行 ～= 写）
   在阵列的类中定义读次数和写次数，最后分别根据阵列类型和操作类型来计算功耗和时间。
   这样可能存在漏洞：SA执行时间、读时间以及magic执行时间、写时间不一定是一致的，之后**硬件再做测量**。

1. Magic
函数运行：
```text
   整列的NOR、NOT、OR、AND、XOR
    已经设计好的全加器
```
 
限制与特点：
```txt
    每列都有SA，占用面积可能会大
    执行过程就是写过程（执行、写同时进行）
    可以进行单个位操作
```
时间：

    -写周期如何计算-
    单周期：NOR NOT OR 读过程
    双周期：AND
    三周期：XOR
    多周期：全加器模块

面积：

    （运行面积）
    宽度等于位宽
    长度=操作数+中间数+结果数
    （总面积）
    指令数*其运行时面积-重写面积
    《设置好上限》

功耗：

    指令数*各指令功耗

外围电路单位数： 
`操作数位数`

2. SA
函数运行：
```text
整行的NOT、OR、AND、XOR
已经设计好的全加器
```
    
限制与特点：
```text
    一个阵列只用一个SA
    执行、读（可以）同时进行
    读和写必须串行
    读写执行都要占用SA，如果存在同一个阵列中的数要并行执行两个操作如
    C=A+B;D=A-B;
    这相当于要把数据读到另一个地方去执行，需要对比其损耗，可能还不如串行
    其实存内逻辑都难以做到（SA和MAGIC）
```

时间：
```text
    -写周期如何计算-
    单周期：AND NOT OR XOR 读过程
    多周期：用以上逻辑组成的其他逻辑/算数运算
```
面积：
```text
    （运行面积）
    宽度等于位宽
    长度=操作数+中间数+结果数
    （总面积）
    指令数*其运行时面积-重写面积
    《设置好上限》
```
    
功耗：
```text
指令数*各指令功耗
```

外围电路单位数：1

3. LUT
函数运行：
```text
    首先烧录
    然后单周期搜索
```
    

限制与特点：
    烧录过程可能比较复杂

时间：
    多周期写
    单周期搜索
面积：
    
功耗：
    指令数*各指令功耗

外围电路单位数：

相关参数设定：
    1. 任意按位运算：n位，n个LUT，我们将LUT拆成若干个lut-2来使用
    2. 常数乘法（移位运算）：
**规定：将向量常数乘法都用移位操作拆分、表示**
查阅了不少资料，并没有找到一个确切的说法，我们当前只能用EDA得出的结果来进行代码的编写
        Vivado综合结果：N位，N个LUT,N个D触发器，N级联，时间：N个时钟周期
        Yosys综合结果：N位，N个lut,N个触发器，3级联，时间：？带反馈
        1.4位
            Number of cells:
            $lut-4                         4    1+（4）+3
            $lut-6                         4    1+（4）+3   
            $lut-8                         4    1+（4）+3
        2.8位
            Number of cells:
            $lut-4                         8    1+（8）+7
            $lut-6                         8    1+（8）+7   
            $lut-8                         8    1+（8）+7
        3.16位
            Number of cells:
            $lut-4                         16    1+（16）+15
            $lut-6                         16    1+（16）+15   
            $lut-8                         16    1+（16）+15
        4.32位
            Number of cells:
            $lut-4                         32    1+（32）+31
            $lut-6                         32    1+（32）+31  
            $lut-8                         32    1+（32）+31
    3. 向量加法
        Yosys综合结果：
        1.32+32
                Number of cells:
                $lut-4                         105  20+6+10+5+2+10+4+2+8+2+13+3+12+4+4（15）
                $lut-6                          85  20+1+12+4+4+11+15+18（8）
                $lut-8                          71  18+2+2+14+1+1+13+20（8）
        2.16+16
                Number of cells:
                $lut-4                         47  12-2-8-3-3-5-7-1-6（9）
                $lut-6                         37  10-1-9-7-10（5）
                $lut-8                         29  11-1-7-10（4）
        3.8+8
                Number of cells:
                $lut-4                         18  4-2-1-4-1-3-1-2（8）
                $lut-6                         15  6-1-4-4（4）
                $lut-8                         10  5-1-4（3）
        4.4+4
                Number of cells:
                $lut-4                          6  3-1-2（3）
                $lut-6                          5  3-2（2）
                $lut-8                          4  4
        5.2+2
                Number of cells:                  2
                $lut-4                          2  2
                $lut-6                          2  2
                $lut-8                          2  2
    4. 向量相乘
        向量 mul 向量：本质上是and操作+移位
        1.32\*32
                Number of cells:
                $lut-4                       2900
                $lut-6                       2145
                $lut-8                       1614
        2.16\*16
                Number of cells:
                $lut-4                        739  （30）
                $lut-6                        518  （21）
                $lut-8                        420  （15）
        3.8\*8
                Number of cells:
                $lut-4                        186  （20）
                $lut-6                        127  （11）
                $lut                           91  （10）
        4.4\*4
                Number of cells:
                $lut-4                         35  12-1-1-7-6-1-1-4-2（9）
                $lut-6                         23  10-5-1-1-4-2（6）
                $lut                            8  8
        5.2\*2
                Number of cells:
                $lut                            4  4
                $lut                            4  4
                $lut                            4  4


二，调度问题

**控制步**

写出的控制步序列是8，统计的控制步数量可能更小，4或5，在存在分支时，可能会直接跳转，不执行某一个控制步。
**统计出的控制步骤数量影响的是执行时间/功耗等事件相关参数，可能并不影响硬件资源的数量（在存算一体中）**

一个控制步中可能含有多个操作

循环控制步的统计：
```text
在循环结构中，代码段会被重复执行多次，这可能会导致控制步的重复。
因此，循环控制步统计需要对循环次数进行考虑。
通常，循环控制步数可以计算为：循环内部操作的控制步数 × 循环次数。
对于复杂的循环结构，可能需要对循环内部的操作进行分析和优化，以提高综合结果的性能和资源利用率
```
分支控制步的统计
```text
在分支结构中，代码段可能会被分为不同的路径，这可能会导致控制步的分支。
因此，分支控制步统计需要考虑所有可能的路径和它们的控制步数。
一种常见的方法是使用基于条件概率的方法进行分支控制步数的估算，
从而在不完全展开分支结构的情况下对控制步数进行估算。
```
**关于分支**：true和false不可能并行执行，因此可以考虑将数据放在同一个阵列中


数据不可能写到同一个阵列中
不同阵列之前的数据有互相调用关系时候要考虑对《时间、面积、功耗》的影响
前提：不考虑路由开销
时间增量：读周期+写周期
面积增量：调用操作数面积
功耗增量：操作数读功耗+写功耗

三，DSE问题
时间这一点，是使用仿真模拟出来的时间
还是使用代码中跑出来的周期

**DSE迭代应该怎么写？**


四，输入输出
输入：CDFG，也就是JSON
输出：各项资源的数量和参数